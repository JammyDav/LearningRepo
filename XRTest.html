<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Virtual Pipette Calibration Lab (CBRE Branded)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; font-family: 'Lato', sans-serif; overflow: hidden; }
        #scene-container { width: 100vw; height: 100vh; }
        #vr-button { position: absolute; bottom: 20px; right: 20px; }
    </style>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>
</head>
<body class="bg-zinc-900 text-white">

    <div id="scene-container"></div>

    <script type="module">
        window.addEventListener('error', function(event) {
            const errorMsg = `An unexpected error occurred which may cause a black screen:
Message: ${event.message}
File: ${event.filename}
Line: ${event.lineno}, Column: ${event.colno}`;
            // Use a simple alert to ensure the error is visible.
            alert(errorMsg);
        });

        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

        // --- VR BUTTON UTILITY ---
        class VRButton {
            static createButton(renderer, onSessionStart, onSessionEnd) {
                const button = document.createElement('button');
                function showEnterVR() {
                    let currentSession = null;
                    async function onSessionStarted(session) {
                        console.log("WebXR session starting...");
                        session.addEventListener('end', onSessionEnded);
                        try {
                            await renderer.xr.setSession(session);
                            button.textContent = 'EXIT VR';
                            currentSession = session;
                            console.log("WebXR session set on renderer.");
                            if (typeof onSessionStart === 'function') onSessionStart();
                        } catch (e) {
                            console.error("Failed to set renderer XR session", e);
                            alert("An error occurred while setting up the VR session.");
                        }
                    }

                    function onSessionEnded() {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = 'ENTER VR';
                        currentSession = null;
                        if (typeof onSessionEnd === 'function') onSessionEnd();
                    }
                    
                    button.style.display = '';
                    button.style.cursor = 'pointer';
                    button.style.position = 'absolute';
                    button.style.right = '20px';
                    button.style.bottom = '20px';
                    button.style.padding = '12px 24px';
                    button.style.border = '1px solid #fff';
                    button.style.borderRadius = '4px';
                    button.style.background = 'rgba(0,0,0,0.5)';
                    button.style.color = '#fff';
                    button.style.font = 'normal 16px Lato, sans-serif';
                    button.textContent = 'ENTER VR';
                    button.onmouseenter = () => { button.style.opacity = '1.0'; };
                    button.onmouseleave = () => { button.style.opacity = '0.9'; };

                    button.onclick = () => {
                        if (currentSession === null) {
                            const sessionInit = { optionalFeatures: ['local-floor', 'bounded-floor'] };
                            navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted).catch(err => {
                                console.error("Failed to request WebXR session:", err);
                                alert("Could not start VR session. Please ensure your device supports WebXR and it is enabled.");
                            });
                        } else {
                            currentSession.end();
                        }
                    };
                }
                function disableButton() {
                    button.style.display = '';
                    button.style.cursor = 'auto';
                    button.style.right = '20px';
                    button.style.bottom = '20px';
                    button.textContent = 'VR NOT SUPPORTED';
                    button.onmouseenter = null;
                    button.onmouseleave = null;
                    button.onclick = null;
                }
                if ('xr' in navigator) {
                    button.id = 'VRButton';
                    navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
                        supported ? showEnterVR() : disableButton();
                    });
                    return button;
                } else {
                    const message = document.createElement('a');
                    if (window.isSecureContext === false) {
                        message.href = document.location.href.replace(/^http:/, 'https:');
                        message.innerHTML = 'WEBXR NEEDS HTTPS'; 
                    } else {
                        message.href = 'https://immersiveweb.dev/';
                        message.innerHTML = 'WEBXR NOT AVAILABLE';
                    }
                    message.style.textDecoration = 'none';
                    return message;
                }
            }
        }

        // --- SCENE SETUP ---
        let scene, camera, renderer, controllers = [], orbitControls;
        let bench, balance, beaker, weighBoat, pipette, tareButton, resetButton;
        let vrInstructionPanel, vrResultsPanel, vrBalanceDisplay;

        // --- INTERACTIVE OBJECTS & STATE ---
        const grabbableObjects = [];
        let grabbedObject = null;
        let controllerPointingAt = null;

        // BRANDING: CBRE Colors
        const CBRE_GREEN = '#003F2D';
        const CBRE_DARK_GREY = '#435254';
        const CBRE_LIGHT_GREY = '#CAD1D3';
        const CBRE_HIGHLIGHT_GREEN = '#006A4D';

        const benchPos = { x: 0, y: 0.4, z: -0.8 };
        const balancePos = { x: -0.5, y: benchPos.y + 0.055, z: benchPos.z };
        const beakerPos = { x: 0.5, y: benchPos.y + 0.1, z: benchPos.z };
        const weighBoatStartPos = { x: 0, y: benchPos.y + 0.055, z: benchPos.z + 0.4 };
        const pipetteStartPos = { x: 0, y: benchPos.y + 0.3, z: benchPos.z - 0.2 };

        let gameState = 'INIT';
        let measurements = [];
        const requiredMeasurements = 5;
        let balanceReading = 0.0;
        let isPipetteFull = false;

        const sceneContainer = document.getElementById('scene-container');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2a303c);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 1);
            camera.lookAt(0, benchPos.y, benchPos.z);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.xr.enabled = true;
            sceneContainer.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer, onSessionStart, onSessionEnd));
            
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.target.set(0, benchPos.y, benchPos.z);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.screenSpacePanning = false;
            orbitControls.maxPolarAngle = Math.PI / 1.5;
            orbitControls.minDistance = 1;
            orbitControls.maxDistance = 4;
            orbitControls.update();

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7.5);
            dirLight.castShadow = true;
            scene.add(dirLight);
            const spotLight = new THREE.SpotLight(0xffffff, 1.0, 10, Math.PI / 4, 0.5, 2);
            spotLight.position.set(0, 3, 0);
            spotLight.target.position.set(0, benchPos.y, benchPos.z);
            spotLight.castShadow = true;
            scene.add(spotLight);
            scene.add(spotLight.target);

            createEnvironment();
            createBalance();
            createBeaker();
            createWeighBoat();
            createPipette();
            createVRUI();
            
            window.addEventListener('resize', onWindowResize, false);
            setGameState('START');
            renderer.setAnimationLoop(render);
        }

        function onSessionStart() {
            orbitControls.enabled = false;
            initControllers();
        }

        function onSessionEnd() {
            orbitControls.enabled = true;
            controllers.forEach(controller => scene.remove(controller));
            controllers = [];
            resetSimulation();
        }

        function createEnvironment() {
            const floorGeom = new THREE.PlaneGeometry(10, 10);
            const floorMat = new THREE.MeshStandardMaterial({ color: CBRE_DARK_GREY });
            const floor = new THREE.Mesh(floorGeom, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            const benchGeom = new THREE.BoxGeometry(2.5, 0.1, 1.2);
            const benchMat = new THREE.MeshStandardMaterial({ color: CBRE_DARK_GREY, metalness: 0.1, roughness: 0.8 });
            bench = new THREE.Mesh(benchGeom, benchMat);
            bench.position.set(benchPos.x, benchPos.y, benchPos.z);
            bench.receiveShadow = true;
            scene.add(bench);
        }

        function createBalance() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.1, 0.25), new THREE.MeshStandardMaterial({ color: CBRE_LIGHT_GREY }));
            base.castShadow = true;
            group.add(base);
            const plate = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.01, 32), new THREE.MeshStandardMaterial({ color: '#ffffff', metalness: 0.5 }));
            plate.position.y = 0.055;
            plate.castShadow = true;
            group.add(plate);
            // FIX: Upgraded material to support emissive properties for highlighting
            const tareButtonGeom = new THREE.CylinderGeometry(0.02, 0.02, 0.01, 16);
            const tareButtonMat = new THREE.MeshStandardMaterial({ color: CBRE_HIGHLIGHT_GREEN });
            tareButton = new THREE.Mesh(tareButtonGeom, tareButtonMat);
            tareButton.name = 'tareButton';
            tareButton.position.set(0.1, 0.055, 0.08);
            group.add(tareButton);
            balance = group;
            balance.position.set(balancePos.x, balancePos.y, balancePos.z);
            scene.add(balance);
        }

        function createBeaker() {
            const beakerMat = new THREE.MeshPhysicalMaterial({ color: CBRE_LIGHT_GREY, transmission: 0.9, thickness: 0.1, roughness: 0.1 });
            beaker = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.2, 32, 1, true), beakerMat);
            beaker.position.set(beakerPos.x, beakerPos.y, beakerPos.z);
            scene.add(beaker);
            // FIX: Upgraded material to support emissive properties
            const waterMat = new THREE.MeshStandardMaterial({ color: '#63b3ed', transparent: true, opacity: 0.7 });
            const water = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 0.18, 32), waterMat);
            water.position.y = -0.01;
            beaker.add(water);
        }

        function createWeighBoat() {
            const boatMat = new THREE.MeshStandardMaterial({ color: CBRE_LIGHT_GREY, side: THREE.DoubleSide });
            
            const group = new THREE.Group();
            const baseWidth = 0.14;
            const baseDepth = 0.1;
            const wallHeight = 0.04;
            const wallThickness = 0.005;

            const base = new THREE.Mesh(new THREE.BoxGeometry(baseWidth, wallThickness, baseDepth), boatMat);
            base.position.y = wallThickness / 2;
            base.castShadow = true;
            group.add(base);

            const frontWall = new THREE.Mesh(new THREE.BoxGeometry(baseWidth, wallHeight, wallThickness), boatMat);
            frontWall.position.set(0, wallHeight / 2, baseDepth / 2);
            frontWall.castShadow = true;
            group.add(frontWall);

            const backWall = new THREE.Mesh(new THREE.BoxGeometry(baseWidth, wallHeight, wallThickness), boatMat);
            backWall.position.set(0, wallHeight / 2, -baseDepth / 2);
            backWall.castShadow = true;
            group.add(backWall);

            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, baseDepth), boatMat);
            leftWall.position.set(-baseWidth / 2, wallHeight / 2, 0);
            leftWall.castShadow = true;
            group.add(leftWall);

            const rightWall = new THREE.Mesh(new THREE.BoxGeometry(wallThickness, wallHeight, baseDepth), boatMat);
            rightWall.position.set(baseWidth / 2, wallHeight / 2, 0);
            rightWall.castShadow = true;
            group.add(rightWall);

            weighBoat = group;
            weighBoat.position.set(weighBoatStartPos.x, weighBoatStartPos.y, weighBoatStartPos.z);
            weighBoat.name = "weighBoat";
            scene.add(weighBoat);
            grabbableObjects.push(weighBoat);

            const waterInBoatGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.01, 16);
            // FIX: Upgraded material to support emissive properties
            const waterInBoatMat = new THREE.MeshStandardMaterial({ color: '#63b3ed', transparent: true, opacity: 0.9 });
            const waterInBoat = new THREE.Mesh(waterInBoatGeo, waterInBoatMat);
            waterInBoat.name = 'dispensedWater';
            waterInBoat.position.y = wallThickness;
            waterInBoat.visible = false;
            weighBoat.add(waterInBoat);
        }

        function createPipette() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16), new THREE.MeshStandardMaterial({ color: CBRE_LIGHT_GREY }));
            group.add(body);
            const plunger = new THREE.Mesh(new THREE.CylinderGeometry(0.018, 0.018, 0.04, 16), new THREE.MeshStandardMaterial({ color: CBRE_GREEN }));
            plunger.position.y = 0.17;
            plunger.name = 'plunger';
            group.add(plunger);
            // FIX: Inverted tip geometry to be a proper point
            const tip = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.005, 0.08, 16), new THREE.MeshStandardMaterial({ color: CBRE_LIGHT_GREY }));
            tip.position.y = -0.19;
            tip.name = 'pipetteTip';
            group.add(tip);
            
            const waterInPipetteGeo = new THREE.CylinderGeometry(0.018, 0.018, 0.28, 16);
            // FIX: Upgraded material to support emissive properties
            const waterInPipetteMat = new THREE.MeshStandardMaterial({ color: '#63b3ed' });
            const waterInPipette = new THREE.Mesh(waterInPipetteGeo, waterInPipetteMat);
            waterInPipette.name = 'waterInPipette';
            waterInPipette.position.y = -0.01;
            waterInPipette.visible = false;
            group.add(waterInPipette);

            pipette = group;
            pipette.scale.set(1.2, 1.2, 1.2);
            pipette.position.set(pipetteStartPos.x, pipetteStartPos.y, pipetteStartPos.z);
            pipette.name = "pipette";
            scene.add(pipette);
            grabbableObjects.push(pipette);
        }

        function createVRUI() {
            vrInstructionPanel = createTextPanel(512, 300);
            vrInstructionPanel.position.set(-1.2, 1.6, -1.2);
            vrInstructionPanel.rotation.y = Math.PI / 8;
            scene.add(vrInstructionPanel);
            vrResultsPanel = createTextPanel(512, 600);
            vrResultsPanel.position.set(1.2, 1.6, -1.2);
            vrResultsPanel.rotation.y = -Math.PI / 8;
            scene.add(vrResultsPanel);
            
            vrBalanceDisplay = createTextPanel(256, 128);
            vrBalanceDisplay.position.set(0, 0.1, -0.15); // Corrected position
            balance.add(vrBalanceDisplay);

            const resetButtonGeom = new THREE.BoxGeometry(0.2, 0.1, 0.02);
            const resetButtonMat = new THREE.MeshStandardMaterial({ color: CBRE_HIGHLIGHT_GREEN });
            resetButton = new THREE.Mesh(resetButtonGeom, resetButtonMat);
            resetButton.name = 'resetButton';
            resetButton.position.set(0, 1.3, -1.5);
            const resetButtonText = createTextPanel(256, 128);
            updateTextPanel(resetButtonText, ["RESET"]);
            resetButtonText.position.z = 0.011;
            resetButton.add(resetButtonText);
            scene.add(resetButton);
        }
        
        function createTextPanel(canvasWidth, canvasHeight) {
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth; canvas.height = canvasHeight;
            const context = canvas.getContext('2d');
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.9 });
            const geometry = new THREE.PlaneGeometry(canvasWidth / 1024, canvasHeight / 1024);
            const panel = new THREE.Mesh(geometry, material);
            panel.userData = { canvas, context, texture };
            return panel;
        }

        function updateTextPanel(panel, lines) {
            const { canvas, context, texture } = panel.userData;
            context.fillStyle = 'rgba(24, 24, 27, 0.8)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.strokeStyle = CBRE_GREEN;
            context.lineWidth = 10;
            context.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);
            context.fillStyle = 'white';
            context.textBaseline = 'middle';
            
            if (lines.length === 1) {
                context.textAlign = 'center';
                context.font = `bold ${canvas.width/8}px 'Playfair Display'`;
                context.fillText(lines[0], canvas.width/2, canvas.height/2);
            } else {
                context.textAlign = 'left';
                let lineSpacing = canvas.height / (lines.length + 2);
                if (panel === vrResultsPanel) lineSpacing = 55;
                
                context.font = `bold ${canvas.width/18}px 'Playfair Display'`;
                context.fillText(lines[0], 25, lineSpacing);
                
                context.font = `normal ${canvas.width/22}px 'Lato'`;
                for (let i = 1; i < lines.length; i++) {
                    context.fillText(lines[i], 25, lineSpacing * (i + 1.2));
                }
            }
            texture.needsUpdate = true;
        }

        function initControllers() {
            for (let i = 0; i < 2; i++) {
                const controller = renderer.xr.getController(i);
                scene.add(controller);
                controllers.push(controller);
                const handMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, emissive: 0x222222 });
                const palm = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.02), handMat);
                palm.position.z = 0.01;
                controller.add(palm);
                const lineGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
                const line = new THREE.Line(lineGeom);
                line.scale.z = 5;
                controller.add(line);
                controller.addEventListener('selectstart', onSelectStart);
                controller.addEventListener('selectend', onSelectEnd);
                controller.addEventListener('squeezestart', onSqueezeStart);
                controller.addEventListener('squeezeend', onSqueezeEnd);
            }
        }

        function onSqueezeStart(event) {
            const controller = event.target;
            if (grabbedObject) return;
            const controllerPos = controller.getWorldPosition(new THREE.Vector3());
            let closestObj = null;
            let minDistance = 0.15;
            grabbableObjects.forEach(obj => {
                if (obj.parent === scene) {
                    const objPos = obj.getWorldPosition(new THREE.Vector3());
                    const distance = controllerPos.distanceTo(objPos);
                    if (distance < minDistance) {
                        closestObj = obj;
                        minDistance = distance;
                    }
                }
            });
            if (closestObj) {
                controller.attach(closestObj);
                grabbedObject = { object: closestObj, controller };
                if (closestObj.name === 'pipette' && gameState === 'BALANCE_TARED') {
                    setGameState('PIPETTE_HELD');
                }
            }
        }

        function onSqueezeEnd(event) {
            if (grabbedObject) {
                const { object } = grabbedObject;
                const worldPos = object.getWorldPosition(new THREE.Vector3());
                const worldQuat = object.getWorldQuaternion(new THREE.Quaternion());
                scene.attach(object);
                object.position.copy(worldPos);
                object.quaternion.copy(worldQuat);
                if (object.name === 'weighBoat') {
                    const balancePlatePos = balance.children[1].getWorldPosition(new THREE.Vector3());
                    if (object.position.distanceTo(balancePlatePos) < 0.1) {
                        object.position.set(balancePlatePos.x, balancePlatePos.y + 0.015, balancePlatePos.z);
                        object.quaternion.identity();
                        balanceReading = 0.123;
                        setGameState('BOAT_ON_BALANCE');
                    }
                }
                grabbedObject = null;
            }
        }

        function onSelectStart(event) {
            if (controllerPointingAt) {
                if (controllerPointingAt.name === 'tareButton' && (gameState === 'BOAT_ON_BALANCE' || gameState === 'RECORDING_WEIGHT')) {
                    balanceReading = 0.0;
                    if (gameState === 'BOAT_ON_BALANCE') setGameState('BALANCE_TARED');
                    else {
                        weighBoat.getObjectByName('dispensedWater').visible = false;
                        setGameState('BALANCE_TARED');
                    }
                } else if (controllerPointingAt.name === 'resetButton') {
                    resetSimulation();
                }
            } else if (grabbedObject && grabbedObject.object.name === 'pipette') {
                const pipetteObj = grabbedObject.object;
                const plunger = pipetteObj.getObjectByName('plunger');
                const tip = pipetteObj.getObjectByName('pipetteTip');
                const tipPos = tip.getWorldPosition(new THREE.Vector3());

                const beakerTopPos = beaker.getWorldPosition(new THREE.Vector3());
                beakerTopPos.y += 0.1;
                const balancePlatePos = balance.children[1].getWorldPosition(new THREE.Vector3());

                if (gameState === 'PIPETTE_HELD' && tipPos.distanceTo(beakerTopPos) < 0.1) {
                    plunger.position.y = 0.15;
                    isPipetteFull = true;
                    const waterInPipette = pipetteObj.getObjectByName('waterInPipette');
                    waterInPipette.visible = true;
                    waterInPipette.scale.y = 1;
                    setGameState('WATER_ASPIRATED');
                } else if (gameState === 'WATER_ASPIRATED' && tipPos.distanceTo(balancePlatePos) < 0.2) {
                    plunger.position.y = 0.15;
                    isPipetteFull = false;
                    pipetteObj.getObjectByName('waterInPipette').visible = false;
                    const dispensedWeight = 1.0 + (Math.random() - 0.5) * 0.02;
                    balanceReading = dispensedWeight;
                    weighBoat.getObjectByName('dispensedWater').visible = true;
                    setGameState('RECORDING_WEIGHT');
                }
            }
        }
        
        function onSelectEnd(event) {
            if (grabbedObject && grabbedObject.object.name === 'pipette') {
                 grabbedObject.object.getObjectByName('plunger').position.y = 0.17;
            }
        }

        function setGameState(newState) {
            gameState = newState;
            updateVRUI();
        }

        function resetSimulation() {
            if (grabbedObject) {
                const { object } = grabbedObject;
                const worldPos = object.getWorldPosition(new THREE.Vector3());
                const worldQuat = object.getWorldQuaternion(new THREE.Quaternion());
                scene.attach(object);
                object.position.copy(worldPos);
                object.quaternion.copy(worldQuat);
                grabbedObject = null;
            }
            weighBoat.position.set(weighBoatStartPos.x, weighBoatStartPos.y, weighBoatStartPos.z);
            pipette.position.set(pipetteStartPos.x, pipetteStartPos.y, pipetteStartPos.z);
            weighBoat.getObjectByName('dispensedWater').visible = false;
            pipette.getObjectByName('waterInPipette').visible = false;
            measurements = [];
            balanceReading = 0.0;
            isPipetteFull = false;
            setGameState('START');
        }

        function updateVRUI() {
            let instructions = ["Lab Procedure"];
            switch(gameState) {
                case 'START': instructions.push("Grab the weigh boat (use grip button)."); break;
                case 'BOAT_ON_BALANCE': instructions.push("Place boat on balance.", "Point at green TARE button & trigger."); break;
                case 'BALANCE_TARED': instructions.push("Grab the micropipette."); break;
                case 'PIPETTE_HELD': instructions.push("Move pipette tip into beaker, press trigger."); break;
                case 'WATER_ASPIRATED': instructions.push("Move pipette over boat, press trigger."); break;
                case 'RECORDING_WEIGHT':
                    instructions.push(`Measurement ${measurements.length} recorded.`, "Press TARE button again.");
                    if (measurements.length >= requiredMeasurements) setGameState('ANALYSIS');
                    break;
                case 'ANALYSIS':
                    instructions.push("All measurements complete.", "Analyzing results...");
                    calculateStatistics();
                    break;
                default: instructions.push("Welcome! Grab the weigh boat."); break;
            }
            updateTextPanel(vrInstructionPanel, instructions);

            let results = [`Measurements (${measurements.length}/${requiredMeasurements})`];
            measurements.forEach((w, i) => results.push(`- Sample ${i+1}: ${w.toFixed(4)}g`));
            if (gameState === 'ANALYSIS') {
                const stats = calculateStatistics();
                results.push("---", `Mean: ${stats.mean.toFixed(4)}g`, `StdDev: ${stats.stdDev.toFixed(4)}g`, `Result: ${stats.pass ? 'PASS' : 'FAIL'}`);
            }
            updateTextPanel(vrResultsPanel, results);
        }
        
        function calculateStatistics() {
            const sum = measurements.reduce((a, b) => a + b, 0);
            const mean = sum / measurements.length;
            const sqDiffs = measurements.map(v => (v - mean) ** 2);
            const avgSqDiff = sqDiffs.reduce((a, b) => a + b, 0) / measurements.length;
            const stdDev = Math.sqrt(avgSqDiff);
            const pass = mean >= 0.995 && mean <= 1.005 && stdDev <= 0.006;
            return { mean, stdDev, pass };
        }

        function handleProximityHighlights() {
            const highlightColor = new THREE.Color(CBRE_HIGHLIGHT_GREEN);
            const highlightIntensity = 0.5;
            const highlightDistance = 0.15;

            grabbableObjects.forEach(obj => {
                let isHighlighted = false;
                if(obj.parent === scene) {
                    controllers.forEach(controller => {
                        const controllerPos = controller.getWorldPosition(new THREE.Vector3());
                        const objPos = obj.getWorldPosition(new THREE.Vector3());
                        if(controllerPos.distanceTo(objPos) < highlightDistance) {
                            isHighlighted = true;
                        }
                    });
                }
                
                obj.traverse(child => {
                    if(child.isMesh) {
                        if (!child.material.emissive) {
                            child.material.emissive = new THREE.Color(0x000000);
                        }
                        if(isHighlighted) {
                            child.material.emissive.set(highlightColor);
                            if (child.material.emissiveIntensity !== undefined) {
                                child.material.emissiveIntensity = highlightIntensity;
                            }
                        } else {
                            child.material.emissive.set(0x000000);
                        }
                    }
                });
            });
        }

        function handleControllerRaycasting() {
            const raycaster = new THREE.Raycaster();
            const tempMatrix = new THREE.Matrix4();
            
            let pointedObject = null;
            controllers.forEach(controller => {
                 tempMatrix.identity().extractRotation(controller.matrixWorld);
                 raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                 raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                 const intersects = raycaster.intersectObjects([tareButton, resetButton]);
                 if (intersects.length > 0) {
                     pointedObject = intersects[0].object;
                 }
            });

            if (controllerPointingAt && controllerPointingAt !== pointedObject) {
                 if(controllerPointingAt.name === 'tareButton') controllerPointingAt.material.color.set(CBRE_HIGHLIGHT_GREEN);
                 if(controllerPointingAt.name === 'resetButton') controllerPointingAt.material.color.set(CBRE_HIGHLIGHT_GREEN);
            }

            controllerPointingAt = pointedObject;
            if (controllerPointingAt) {
                controllerPointingAt.material.color.set(CBRE_GREEN);
            }
        }

        function render() {
            if (!renderer.xr.isPresenting) {
                orbitControls.update();
            }

            if (renderer.xr.isPresenting) {
                handleProximityHighlights();
                handleControllerRaycasting();
            }
            updateTextPanel(vrBalanceDisplay, ["Balance", `${balanceReading.toFixed(4)} g`]);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        try {
            init();
        } catch (e) {
            alert(`A critical error occurred on initialization: ${e.message}`);
            console.error(e);
        }

    </script>
</body>
</html>
